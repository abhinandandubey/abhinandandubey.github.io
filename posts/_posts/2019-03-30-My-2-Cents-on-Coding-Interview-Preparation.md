---
layout: post
title: My Two Cents on Coding Interview Preparation
tags: 
cover_url: https://github.com/alivcor/lightforest/raw/master/IMG_2716.JPG
cover_meta: The Majestic NYC Skyline in Summer (c) AD Photography
color_scheme: tango
mathjax: true
mathjax: True
---

<div style="text-align: justify">
<br/>
Coding interviews can be hard - and with emerging hiring techniques in the bay-area companies like _bar-raising_ rounds, it might indeed sound brutal. To me personally, I had a moral blocker when I was faced with the need to solve a never ending list of Leetcode problems - most of which sounded like puzzles. I always used to think that you should be a _good_ programmer - not a robot who knows how to solve puzzles!

My first exposure to these coding interviews was in Fall of 2016 - when I was hunting for an internship for the summer of 2017. I had no prior experience - neither work, nor coding interviews. I was lucky enough to get a few calls from companies in Silicon Valley and a few startups in NYC, thanks to the good reputation Stony Brook has amongst the top CS programs. 

But that wasn't enough. Cracking the GRE, getting a good GPA in the undergrad, toiling through the not-so-easy Graduate Courses, and then the tech industry expects you to have solved another 800 or so puzzles? Bleh.

Well, time passed and I mostly ignored coding interview practice. I was lucky enough to get a job offer from an investment bank in NYC with some basic Data Structures and Algorithms knowledge that I had gained as a part of my undergrad, and some na√Øve interview preparation.

A few weeks into my job, and I start getting calls - first of them being Apple. And out of nowhere, I find myself barely being able to solve the Two Sum problem. Needless to say, I could only last a couple of phone screens. If you are new to this, let me tell you - the big N, (or as they call them "FAANG" on the forums)require you to go through a coding assessment, which is followed by a couple of phone screens (a mix of coding plus some background questions), after which they call you on-site if they feel you're worth it - and then you basically go through anywhere between 4 to 7 rounds - a mix of one-on-one or two-on-one before you finally get an offer. All of these interviews have a 50-100% coding part where they ask a bunch of questions from [HackerRank](https://www.hackerrank.com) and the most celebrated [Leetcode](https://www.leetcode.com). The quality of questions asked and the competency expected varies from brand to brand. If you are talking the likes of Google or Netflix - you're not getting anywhere without having a perfect score in all rounds which have a mix of "LC Hard" and "LC Medium" questions. 

Earlier this year, after the Apple debacle, I was approached by an Amazon recruiter, and was lucky enough to be able to qualify the coding assessment and the preliminary rounds - and was called onsite at the Seattle HQ for a position in New York City. I had less than a month to prepare, and I was looking at a list of ~400 questions for Amazon on Leetcode.

It was hard, it was rough. The first few days were really pathetic and de-moralizing given that it had been a year since I had graduated and I had never before seriously taken up these coding problems. Coming back from work, already tired and then solving these problems, then realizing I couldn't do better than brute-force was such a slap on my face. But I kept going - I identify as a lazy but otherwise hard-working person, but when I am into it - I give my best. Needless to say - the high reward of a potential SDE position at FAANG kept my enthusiasm alive all the time. More than that, I also had some peer-pressure. Everyone at my grad school was making more bucks than me - and while I don't identify as someone who constantly whines looking at my neighbours (in fact, if you look at my instagram for 2018, you'd realize I was living a life!); a feeling was eating me from the inside. 

It was just this sinking feeling that there were opportunities at my door, and I was acting like a douchebag by just being completely oblivious and staying in my comfort zone. 

In the little hours I had, I managed to solve near about 200 problems, although most of them were Easy-Medium. And in doing so, I learned a lot of lessons. I couldn't find these lessons anywhere on the internet and so at the end of it, I decided to write a blog post on it. 

<h2> It's not about solving puzzles </h2>

As I previously mentioned, I just found it stupid to be judged by a couple of coding puzzles. And to be honest, my belief has largely remained unchanged. It doesn't make you the smartest person on the earth. But it _does_ make you a little smarter, and it _does_ make you a better programmer. I learned so much more about Python - my go-to programming language than ever before. I learned so many ways of looking at problems, and gained a better perspective of what I had studied in Algorithms class. In fact I wish this was a part of the curriculum at school - not the whole thing but at least a part of it. 

And not to mention, <b>it made some coding interviews laughably easy</b>. It _does_ help a lot. Once you've solved enough of these tricky problems, your mind magically develops this "algo mind". 

<h2> It's hard because it's not "natural" </h2>

Your brain doesn't work on algorithms, instead, it works on probabilities and years of training and evolution. It's essentially a very complex neural network. So when I am looking at the Two Sum problem, or the Rotting Oranges problem, I'm not maintaining a stupid hashmap, or unconsiously running a BFS at the back of my mind without me actually knowing about it. Rather my brain is just running through a lot of permutations really really quick and running a hit-and-trial with some heuristics which activate neurons which get me an answer which might or might not be correct. 

But when coding, we're actually finding a deterministic solution to the problem, a well structured and optimised list of steps which can get me the answers instead of rummaging through a bunch of hit and trials. That makes it hard. But there's a good news too - your brain is capable of learning how to come up with these steps too - just like you were never taught how to board a flight but you actually figured it out naturally, your brain will, after a while get better at figuring out solutions to compile an algorithm to these problems. It's just a matter of time.

# 
<br/>